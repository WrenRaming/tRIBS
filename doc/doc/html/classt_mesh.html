<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tRIBS: tMesh&lt; tSubNode &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tRIBS
   </div>
   <div id="projectbrief">tRIBS documentation via Oxygen</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classt_mesh-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tMesh&lt; tSubNode &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="t_mesh_8h_source.html">tMesh.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa45693f3a97c82f91c4c2c1d363a2c23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#aa45693f3a97c82f91c4c2c1d363a2c23">tMesh</a> ()</td></tr>
<tr class="separator:aa45693f3a97c82f91c4c2c1d363a2c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b464036abd640952ce68c0468cc1d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a31b464036abd640952ce68c0468cc1d2">tMesh</a> (<a class="el" href="class_simulation_control.html">SimulationControl</a> *)</td></tr>
<tr class="separator:a31b464036abd640952ce68c0468cc1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b5d784c142dd3dfc9dc9ae070603ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a15b5d784c142dd3dfc9dc9ae070603ad">tMesh</a> (<a class="el" href="class_simulation_control.html">SimulationControl</a> *, <a class="el" href="classt_input_file.html">tInputFile</a> &amp;)</td></tr>
<tr class="separator:a15b5d784c142dd3dfc9dc9ae070603ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a09344e17e72b8f61cd15f09be1a37"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a73a09344e17e72b8f61cd15f09be1a37">tMesh</a> (<a class="el" href="classt_mesh.html">tMesh</a> *)</td></tr>
<tr class="separator:a73a09344e17e72b8f61cd15f09be1a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870b7204057d41b82d631bc98b67c8a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a870b7204057d41b82d631bc98b67c8a7">~tMesh</a> ()</td></tr>
<tr class="separator:a870b7204057d41b82d631bc98b67c8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a72a956b713e3ce4cbbb1e3e19604c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a83a72a956b713e3ce4cbbb1e3e19604c">MakeMeshFromScratch</a> (<a class="el" href="classt_input_file.html">tInputFile</a> &amp;)</td></tr>
<tr class="separator:a83a72a956b713e3ce4cbbb1e3e19604c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5d92b3ad8bfe92e0e0ffede3cb742d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#abd5d92b3ad8bfe92e0e0ffede3cb742d">MakeMeshFromInputData</a> (<a class="el" href="classt_input_file.html">tInputFile</a> &amp;)</td></tr>
<tr class="separator:abd5d92b3ad8bfe92e0e0ffede3cb742d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9f870682626c4cd09d057a601654c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a4f9f870682626c4cd09d057a601654c0">MakeMeshFromPoints</a> (<a class="el" href="classt_input_file.html">tInputFile</a> &amp;)</td></tr>
<tr class="separator:a4f9f870682626c4cd09d057a601654c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae28a17ad899ae2f0f4f91df69e15f62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#aae28a17ad899ae2f0f4f91df69e15f62">MakeRandomPointsFromArcGrid</a> (<a class="el" href="classt_input_file.html">tInputFile</a> &amp;)</td></tr>
<tr class="separator:aae28a17ad899ae2f0f4f91df69e15f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f2b6c261b817daccf4f5ca5f6f4bd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#aa7f2b6c261b817daccf4f5ca5f6f4bd9">MakeHexMeshFromArcGrid</a> (<a class="el" href="classt_input_file.html">tInputFile</a> &amp;)</td></tr>
<tr class="separator:aa7f2b6c261b817daccf4f5ca5f6f4bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d76f5e10736bd3678bd73a6d7a28ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#ac1d76f5e10736bd3678bd73a6d7a28ad">MakeLayersFromInputData</a> (<a class="el" href="classt_input_file.html">tInputFile</a> &amp;)</td></tr>
<tr class="separator:ac1d76f5e10736bd3678bd73a6d7a28ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18344f25afa738e9128de72ca28ceb24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a18344f25afa738e9128de72ca28ceb24">MakePointFromFileArcInfo</a> (<a class="el" href="classt_input_file.html">tInputFile</a> &amp;)</td></tr>
<tr class="separator:a18344f25afa738e9128de72ca28ceb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624048904530b99629022ad95a6adddc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a624048904530b99629022ad95a6adddc">MakePointFromFileArcInfoGen</a> (<a class="el" href="classt_input_file.html">tInputFile</a> &amp;)</td></tr>
<tr class="separator:a624048904530b99629022ad95a6adddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec739b48323a5be15c27ff984958474"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a2ec739b48323a5be15c27ff984958474">MakeMeshFromTriangulator</a> (<a class="el" href="classt_input_file.html">tInputFile</a> &amp;)</td></tr>
<tr class="separator:a2ec739b48323a5be15c27ff984958474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86514e02499ed0f497c6e3e174f5625c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a86514e02499ed0f497c6e3e174f5625c">MakeMeshFromMeshBuilder</a> (<a class="el" href="classt_input_file.html">tInputFile</a> &amp;)</td></tr>
<tr class="separator:a86514e02499ed0f497c6e3e174f5625c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725f9f50219ac7e4b4e80f7f61745d34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a725f9f50219ac7e4b4e80f7f61745d34">Print</a> ()</td></tr>
<tr class="separator:a725f9f50219ac7e4b4e80f7f61745d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac7892985d902ac09e63147d8d59147"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#aeac7892985d902ac09e63147d8d59147">MakeCCWEdges</a> ()</td></tr>
<tr class="separator:aeac7892985d902ac09e63147d8d59147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58bb60c14c400f821efa812b0ad341a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a58bb60c14c400f821efa812b0ad341a4">setVoronoiVertices</a> ()</td></tr>
<tr class="separator:a58bb60c14c400f821efa812b0ad341a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355454e97230dfb15b441c7453032cb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a355454e97230dfb15b441c7453032cb1">CalcVoronoiEdgeLengths</a> ()</td></tr>
<tr class="separator:a355454e97230dfb15b441c7453032cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c03a0d5246105efdb77cc6853c57faf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a0c03a0d5246105efdb77cc6853c57faf">CalcVAreas</a> ()</td></tr>
<tr class="separator:a0c03a0d5246105efdb77cc6853c57faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadcf7237806076b4b6d28b374647caf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classt_triangle.html">tTriangle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#adadcf7237806076b4b6d28b374647caf">LocateTriangle</a> (double, double)</td></tr>
<tr class="separator:adadcf7237806076b4b6d28b374647caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96748c5d7afab4ba072abe8b161a85a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classt_triangle.html">tTriangle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#ad96748c5d7afab4ba072abe8b161a85a">LocateNewTriangle</a> (double, double)</td></tr>
<tr class="separator:ad96748c5d7afab4ba072abe8b161a85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc1693e4eb4d647985b1982c531e06f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classt_triangle.html">tTriangle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a6dc1693e4eb4d647985b1982c531e06f">TriWithEdgePtr</a> (<a class="el" href="classt_edge.html">tEdge</a> *)</td></tr>
<tr class="separator:a6dc1693e4eb4d647985b1982c531e06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f26b4897c91d04a65b9a496c9b80fd7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a4f26b4897c91d04a65b9a496c9b80fd7">DeleteNode</a> (<a class="el" href="classt_list_node.html">tListNode</a>&lt; tSubNode &gt; *, int repairFlag=1)</td></tr>
<tr class="separator:a4f26b4897c91d04a65b9a496c9b80fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46dc5c91f0cff874022a5e483e14dd7e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a46dc5c91f0cff874022a5e483e14dd7e">DeleteNode</a> (tSubNode *, int repairFlag=1)</td></tr>
<tr class="separator:a46dc5c91f0cff874022a5e483e14dd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a397275be803052818e0ee8c5d6ab6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#ae9a397275be803052818e0ee8c5d6ab6">ExtricateNode</a> (tSubNode *, <a class="el" href="classt_ptr_list.html">tPtrList</a>&lt; tSubNode &gt; &amp;)</td></tr>
<tr class="separator:ae9a397275be803052818e0ee8c5d6ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c4c76a689aac700b82d9cc0ae2dc49"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#ac3c4c76a689aac700b82d9cc0ae2dc49">DeleteEdge</a> (<a class="el" href="classt_edge.html">tEdge</a> *)</td></tr>
<tr class="separator:ac3c4c76a689aac700b82d9cc0ae2dc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e45ad3f47553de38d256c7e2928653"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#ae2e45ad3f47553de38d256c7e2928653">ExtricateEdge</a> (<a class="el" href="classt_edge.html">tEdge</a> *)</td></tr>
<tr class="separator:ae2e45ad3f47553de38d256c7e2928653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad291447852bc92ff12cca1d00b7c77"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#abad291447852bc92ff12cca1d00b7c77">DeleteTriangle</a> (<a class="el" href="classt_triangle.html">tTriangle</a> *)</td></tr>
<tr class="separator:abad291447852bc92ff12cca1d00b7c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843e3ff646d320a57acc5ff736cab517"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a843e3ff646d320a57acc5ff736cab517">ExtricateTriangle</a> (<a class="el" href="classt_triangle.html">tTriangle</a> *)</td></tr>
<tr class="separator:a843e3ff646d320a57acc5ff736cab517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa156c800db8793912a3020e752f76f13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#aa156c800db8793912a3020e752f76f13">RepairMesh</a> (<a class="el" href="classt_ptr_list.html">tPtrList</a>&lt; tSubNode &gt; &amp;)</td></tr>
<tr class="separator:aa156c800db8793912a3020e752f76f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d68f7364f7f7f07d91faabac2e2e63c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a6d68f7364f7f7f07d91faabac2e2e63c">AddEdgeAndMakeTriangle</a> (<a class="el" href="classt_ptr_list.html">tPtrList</a>&lt; tSubNode &gt; &amp;, <a class="el" href="classt_ptr_list_iter.html">tPtrListIter</a>&lt; tSubNode &gt; &amp;)</td></tr>
<tr class="separator:a6d68f7364f7f7f07d91faabac2e2e63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656c98c2bd4f8366c991cbe1a21f1309"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a656c98c2bd4f8366c991cbe1a21f1309">MakeTriangle</a> (<a class="el" href="classt_ptr_list.html">tPtrList</a>&lt; tSubNode &gt; &amp;, <a class="el" href="classt_ptr_list_iter.html">tPtrListIter</a>&lt; tSubNode &gt; &amp;)</td></tr>
<tr class="separator:a656c98c2bd4f8366c991cbe1a21f1309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854540860a3a5e1d6653adf31c62a15a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a854540860a3a5e1d6653adf31c62a15a">AddEdge</a> (tSubNode *, tSubNode *, tSubNode *)</td></tr>
<tr class="separator:a854540860a3a5e1d6653adf31c62a15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dfcf7230a9827417d8c985feee1579d"><td class="memItemLeft" align="right" valign="top">tSubNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a4dfcf7230a9827417d8c985feee1579d">AddNode</a> (tSubNode &amp;, int updatemesh=0, double time=0.0)</td></tr>
<tr class="separator:a4dfcf7230a9827417d8c985feee1579d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ed489278cbdcec8e2516f544aa8000"><td class="memItemLeft" align="right" valign="top">tSubNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a19ed489278cbdcec8e2516f544aa8000">AddNodeAt</a> (<a class="el" href="classt_array.html">tArray</a>&lt; double &gt; &amp;, double time=0.0)</td></tr>
<tr class="separator:a19ed489278cbdcec8e2516f544aa8000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff1becca6714d7233aa11ea529afd2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a2ff1becca6714d7233aa11ea529afd2e">AddNodesAround</a> (tSubNode *, double time=0.0)</td></tr>
<tr class="separator:a2ff1becca6714d7233aa11ea529afd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42828f1f1dd4bd72cf811136ee82cb67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classt_mesh_list.html">tMeshList</a>&lt; <a class="el" href="classt_edge.html">tEdge</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a42828f1f1dd4bd72cf811136ee82cb67">getEdgeList</a> ()</td></tr>
<tr class="separator:a42828f1f1dd4bd72cf811136ee82cb67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100711530a0f6b2b2d8e70f307da34c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classt_mesh_list.html">tMeshList</a>&lt; tSubNode &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a100711530a0f6b2b2d8e70f307da34c7">getNodeList</a> ()</td></tr>
<tr class="separator:a100711530a0f6b2b2d8e70f307da34c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06a218520980fd50da2646452d1646c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classt_mesh_list.html">tMeshList</a>&lt; tSubNode &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#ae06a218520980fd50da2646452d1646c">getUnsortList</a> ()</td></tr>
<tr class="separator:ae06a218520980fd50da2646452d1646c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77943f86a3c14f52bf1aee5932050b5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classt_list.html">tList</a>&lt; <a class="el" href="classt_triangle.html">tTriangle</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a77943f86a3c14f52bf1aee5932050b5f">getTriList</a> ()</td></tr>
<tr class="separator:a77943f86a3c14f52bf1aee5932050b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86337d3cf4ebc31b178f5dbbf51f76dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classt_edge.html">tEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a86337d3cf4ebc31b178f5dbbf51f76dc">getEdgeComplement</a> (<a class="el" href="classt_edge.html">tEdge</a> *)</td></tr>
<tr class="separator:a86337d3cf4ebc31b178f5dbbf51f76dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688bd68a729d729d62fe008b493e233d"><td class="memItemLeft" align="right" valign="top">tSubNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a688bd68a729d729d62fe008b493e233d">getNodeFromID</a> (int id)</td></tr>
<tr class="separator:a688bd68a729d729d62fe008b493e233d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9681b88ea3beec71b25c3fadbc9e664"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#ab9681b88ea3beec71b25c3fadbc9e664">setNodeFromID</a> (int id, tSubNode *node)</td></tr>
<tr class="separator:ab9681b88ea3beec71b25c3fadbc9e664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8545217f484745be3bfb04ab288028"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#afe8545217f484745be3bfb04ab288028">allocateNodeTable</a> (int sz)</td></tr>
<tr class="separator:afe8545217f484745be3bfb04ab288028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91878b784d08004a008a6d3721a47f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#aa91878b784d08004a008a6d3721a47f6">deleteNodeTable</a> ()</td></tr>
<tr class="separator:aa91878b784d08004a008a6d3721a47f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5058ee5d62594eac66b1ed67cdc538"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#aff5058ee5d62594eac66b1ed67cdc538">CheckMeshConsistency</a> (int boundaryCheckFlag=1)</td></tr>
<tr class="separator:aff5058ee5d62594eac66b1ed67cdc538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbbf53e424f2aeee81467e11c200480"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a8cbbf53e424f2aeee81467e11c200480">CheckMeshConsistency</a> (<a class="el" href="classt_input_file.html">tInputFile</a> &amp;, int boundaryCheckFlag=1)</td></tr>
<tr class="separator:a8cbbf53e424f2aeee81467e11c200480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2549f47aad9659b507aca8f30ff66f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a6b2549f47aad9659b507aca8f30ff66f">ChangePointOrder</a> (<a class="el" href="classt_input_file.html">tInputFile</a> &amp;, <a class="el" href="classt_list.html">tList</a>&lt; double &gt; XY)</td></tr>
<tr class="separator:a6b2549f47aad9659b507aca8f30ff66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f4924148c66d771a3bd47ef87fef32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a79f4924148c66d771a3bd47ef87fef32">UpdateMesh</a> ()</td></tr>
<tr class="separator:a79f4924148c66d771a3bd47ef87fef32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5468c8f79d9591088d6671cc7b46192"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#ab5468c8f79d9591088d6671cc7b46192">CheckForFlip</a> (<a class="el" href="classt_triangle.html">tTriangle</a> *, int, int)</td></tr>
<tr class="separator:ab5468c8f79d9591088d6671cc7b46192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39476cfe04376ab3494c764cc0df0a09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a39476cfe04376ab3494c764cc0df0a09">FlipEdge</a> (<a class="el" href="classt_triangle.html">tTriangle</a> *, <a class="el" href="classt_triangle.html">tTriangle</a> *, int, int)</td></tr>
<tr class="separator:a39476cfe04376ab3494c764cc0df0a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61eaa1703ddd3329047402d428dd2e44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classt_edge.html">tEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a61eaa1703ddd3329047402d428dd2e44">IntersectsAnyEdge</a> (<a class="el" href="classt_edge.html">tEdge</a> *)</td></tr>
<tr class="separator:a61eaa1703ddd3329047402d428dd2e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae380b45bd056286aca9911413adf8431"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#ae380b45bd056286aca9911413adf8431">CheckTriEdgeIntersect</a> ()</td></tr>
<tr class="separator:ae380b45bd056286aca9911413adf8431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203caceeb74bd9d0c8d38ce848f1ee6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a203caceeb74bd9d0c8d38ce848f1ee6a">CheckLocallyDelaunay</a> ()</td></tr>
<tr class="separator:a203caceeb74bd9d0c8d38ce848f1ee6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d673bc9803fa274d638f2fd098d19d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a0d673bc9803fa274d638f2fd098d19d5">MoveNodes</a> (double time=0.0)</td></tr>
<tr class="separator:a0d673bc9803fa274d638f2fd098d19d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77692808013d1f6124fabe7c261a48e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#ab77692808013d1f6124fabe7c261a48e">TellAboutNode</a> (tSubNode *)</td></tr>
<tr class="separator:ab77692808013d1f6124fabe7c261a48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e9774031924a84293c81b20d4233aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a94e9774031924a84293c81b20d4233aa">writeRestart</a> (fstream &amp;)</td></tr>
<tr class="separator:a94e9774031924a84293c81b20d4233aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3307092e28fb1306c09001e524e3a7ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a3307092e28fb1306c09001e524e3a7ee">readRestart</a> (fstream &amp;)</td></tr>
<tr class="separator:a3307092e28fb1306c09001e524e3a7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4055127efa626a0d087f0a7377ac0b6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a4055127efa626a0d087f0a7377ac0b6a">DumpEdges</a> ()</td></tr>
<tr class="separator:a4055127efa626a0d087f0a7377ac0b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae372729b6c2bcee73721193f0ee0d18b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#ae372729b6c2bcee73721193f0ee0d18b">DumpSpokes</a> (tSubNode *)</td></tr>
<tr class="separator:ae372729b6c2bcee73721193f0ee0d18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556a97b81eb290243a19e3e0d0f635ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a556a97b81eb290243a19e3e0d0f635ff">DumpTriangles</a> ()</td></tr>
<tr class="separator:a556a97b81eb290243a19e3e0d0f635ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ac4616c0e776d707ffb4d4d615b456"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a79ac4616c0e776d707ffb4d4d615b456">DumpNodes</a> ()</td></tr>
<tr class="separator:a79ac4616c0e776d707ffb4d4d615b456"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a071289cd4f1aa4c9acc4beb384b55552"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_simulation_control.html">SimulationControl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a071289cd4f1aa4c9acc4beb384b55552">simCtrl</a></td></tr>
<tr class="separator:a071289cd4f1aa4c9acc4beb384b55552"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab176a2011b791982e7f6d9a0b08f1160"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#ab176a2011b791982e7f6d9a0b08f1160">nnodes</a></td></tr>
<tr class="separator:ab176a2011b791982e7f6d9a0b08f1160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485f86a92919290f8a69075f11915a84"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a485f86a92919290f8a69075f11915a84">nedges</a></td></tr>
<tr class="separator:a485f86a92919290f8a69075f11915a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63653c1fecfc91c8443f3f61f3be5cb7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a63653c1fecfc91c8443f3f61f3be5cb7">ntri</a></td></tr>
<tr class="separator:a63653c1fecfc91c8443f3f61f3be5cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e13816739595f9f16db3953a328494d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classt_mesh_list.html">tMeshList</a>&lt; tSubNode &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a7e13816739595f9f16db3953a328494d">nodeList</a></td></tr>
<tr class="separator:a7e13816739595f9f16db3953a328494d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da103b2cf4437432a95b996b802db6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classt_mesh_list.html">tMeshList</a>&lt; tSubNode &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a8da103b2cf4437432a95b996b802db6c">unsortList</a></td></tr>
<tr class="separator:a8da103b2cf4437432a95b996b802db6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7508e9f09571ca93db5e4fd1bd68411f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classt_mesh_list.html">tMeshList</a>&lt; <a class="el" href="classt_edge.html">tEdge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a7508e9f09571ca93db5e4fd1bd68411f">edgeList</a></td></tr>
<tr class="separator:a7508e9f09571ca93db5e4fd1bd68411f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb12cff37beb9d3aad9cb462e8665a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classt_list.html">tList</a>&lt; <a class="el" href="classt_triangle.html">tTriangle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a0bb12cff37beb9d3aad9cb462e8665a2">triList</a></td></tr>
<tr class="separator:a0bb12cff37beb9d3aad9cb462e8665a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27ff2bc94d0a6970e5b082f2e3ce2c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#ab27ff2bc94d0a6970e5b082f2e3ce2c6">miNextNodeID</a></td></tr>
<tr class="separator:ab27ff2bc94d0a6970e5b082f2e3ce2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab920491f63bc1a50cd4c29a937195429"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#ab920491f63bc1a50cd4c29a937195429">miNextEdgID</a></td></tr>
<tr class="separator:ab920491f63bc1a50cd4c29a937195429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bbda0dc1dc090e066e20e9f0d3fee63"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a7bbda0dc1dc090e066e20e9f0d3fee63">miNextTriID</a></td></tr>
<tr class="separator:a7bbda0dc1dc090e066e20e9f0d3fee63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be9ed8ac9116e8c46c66c405723f46f"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a5be9ed8ac9116e8c46c66c405723f46f">seed</a></td></tr>
<tr class="separator:a5be9ed8ac9116e8c46c66c405723f46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e9e63101d16978322d5d2732edaeb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classt_triangle.html">tTriangle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#ab6e9e63101d16978322d5d2732edaeb8">mSearchOriginTriPtr</a></td></tr>
<tr class="separator:ab6e9e63101d16978322d5d2732edaeb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0d563b4b8371c039f57d65863a4bad"><td class="memItemLeft" align="right" valign="top">tSubNode **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classt_mesh.html#a0d0d563b4b8371c039f57d65863a4bad">NodeTable</a></td></tr>
<tr class="separator:a0d0d563b4b8371c039f57d65863a4bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa45693f3a97c82f91c4c2c1d363a2c23" name="aa45693f3a97c82f91c4c2c1d363a2c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45693f3a97c82f91c4c2c1d363a2c23">&#9670;&#160;</a></span>tMesh() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;<a class="el" href="classt_mesh.html">::tMesh</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a31b464036abd640952ce68c0468cc1d2" name="a31b464036abd640952ce68c0468cc1d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b464036abd640952ce68c0468cc1d2">&#9670;&#160;</a></span>tMesh() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;<a class="el" href="classt_mesh.html">::tMesh</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_simulation_control.html">SimulationControl</a> *&#160;</td>
          <td class="paramname"><em>simCtrPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a15b5d784c142dd3dfc9dc9ae070603ad" name="a15b5d784c142dd3dfc9dc9ae070603ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b5d784c142dd3dfc9dc9ae070603ad">&#9670;&#160;</a></span>tMesh() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;<a class="el" href="classt_mesh.html">::tMesh</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_simulation_control.html">SimulationControl</a> *&#160;</td>
          <td class="paramname"><em>simCtrPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classt_input_file.html">tInputFile</a> &amp;&#160;</td>
          <td class="paramname"><em>infile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html">tMesh( infile )</a>: Reads from infile whether it is to reconstruct a mesh from input, construct a mesh from a list of points, or other options including from Arc/Info files.</p>
<p>Calls: <a class="el" href="classt_input_file.html#a2a2d2600565a0124f37f7bff7608e28d">tInputFile::ReadItem</a>, MakeMeshFromInputData( infile ), MakeMeshFromPoints( infile ), MakeRandomPointsFromArcGrid( infile ), MakeHexMeshFromArcGrid( infile ), MakePointFromFileArcInfo( infile ), MakePointFromFileArcInfoGen( infile ), MakeMeshFromScratch( infile ), MakeLayersFromInputData( infile )</p>
<p>Options in MESHINPUT: 1 Create mesh by reading data files (*.edges, *.nodes, *.tri) 2 Create new mesh from list of points (*.points) 3 Create random mesh from regular arc ascii grid 4 Create hex mesh from regular arc ascii grid 5 Create points file from Arc/Info Ungeneratetin (*.net) 6 Create points file from Arc/Info Ungeneratetin (*.lin &amp; *.pnt) 7 Create mesh from scratch using parameters </p>

</div>
</div>
<a id="a73a09344e17e72b8f61cd15f09be1a37" name="a73a09344e17e72b8f61cd15f09be1a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73a09344e17e72b8f61cd15f09be1a37">&#9670;&#160;</a></span>tMesh() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;<a class="el" href="classt_mesh.html">::tMesh</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt; *&#160;</td>
          <td class="paramname"><em>originalMesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a870b7204057d41b82d631bc98b67c8a7" name="a870b7204057d41b82d631bc98b67c8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a870b7204057d41b82d631bc98b67c8a7">&#9670;&#160;</a></span>~tMesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::~<a class="el" href="classt_mesh.html">tMesh</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a854540860a3a5e1d6653adf31c62a15a" name="a854540860a3a5e1d6653adf31c62a15a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854540860a3a5e1d6653adf31c62a15a">&#9670;&#160;</a></span>AddEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::AddEdge </td>
          <td>(</td>
          <td class="paramtype">tSubNode *&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tSubNode *&#160;</td>
          <td class="paramname"><em>node2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tSubNode *&#160;</td>
          <td class="paramname"><em>node3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#a854540860a3a5e1d6653adf31c62a15a">tMesh::AddEdge</a></p>
<p>Function to add edge pair between two nodes. Resets edge IDs.</p>
<p>Inputs: three nodes; edge is added between first two, and third should be CCW 3rd member of triangle. Returns: 1 if successful, 0 if not</p>
<p>Created: SL fall, '97 Modified: SL 10/98&ndash;routine sometimes failed when node1 (or node2) had had edges to neither node2 (or node1) nor node3; to fix, replaced the "assert( !( spokIter.AtEnd() ) )"'s with new algorithm to find where new spoke should be inserted: finds where the sequence of 3 spoke unit vectors, including the new one in the middle, are CCW; calls new global function, <a class="el" href="classt_array.html">tArray&lt; double &gt;</a> <a class="el" href="global_fns_8cpp.html#a37e1a1659608574d0af94a58fac9efd2">UnitVector( tEdge* )</a>.</p><ul>
<li>GT 1/99 &ndash; to avoid compiler warning, now stores output of UnitVector calls in arrays p1, p2, p3, which are then sent as arguments to PointsCCW.</li>
<li>GT 2/99 &ndash; added calls to WelcomeCCWNeighbor and AttachNewSpoke to update CCW edge connectivity </li>
</ul>

</div>
</div>
<a id="a6d68f7364f7f7f07d91faabac2e2e63c" name="a6d68f7364f7f7f07d91faabac2e2e63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d68f7364f7f7f07d91faabac2e2e63c">&#9670;&#160;</a></span>AddEdgeAndMakeTriangle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::AddEdgeAndMakeTriangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classt_ptr_list.html">tPtrList</a>&lt; tSubNode &gt; &amp;&#160;</td>
          <td class="paramname"><em>nbrList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classt_ptr_list_iter.html">tPtrListIter</a>&lt; tSubNode &gt; &amp;&#160;</td>
          <td class="paramname"><em>nbrIter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#a6d68f7364f7f7f07d91faabac2e2e63c">tMesh::AddEdgeAndMakeTriangle</a></p>
<p>Function to add the "missing" edge and make the triangle. Formerly more complicated than <a class="el" href="classt_mesh.html#a854540860a3a5e1d6653adf31c62a15a">AddEdge()</a> and <a class="el" href="classt_mesh.html#a656c98c2bd4f8366c991cbe1a21f1309">MakeTriangle()</a>; now simply calls these functions.</p>
<p>Inputs: a tPtrList&lt;tSubNode&gt; of nodes in triangle; a <a class="el" href="classt_ptr_list_iter.html">tPtrListIter</a> object, the iterator of the latter list; edge is added between node currently pointed to by iterator and the node-after-next. List should be circular. Calls: <a class="el" href="classt_mesh.html#a854540860a3a5e1d6653adf31c62a15a">AddEdge()</a>, <a class="el" href="classt_mesh.html#a656c98c2bd4f8366c991cbe1a21f1309">MakeTriangle()</a> Created: SL fall, '97 Modified: SL 10/98 to call <a class="el" href="classt_mesh.html#a854540860a3a5e1d6653adf31c62a15a">AddEdge()</a> and <a class="el" href="classt_mesh.html#a656c98c2bd4f8366c991cbe1a21f1309">MakeTriangle()</a> </p>

</div>
</div>
<a id="a4dfcf7230a9827417d8c985feee1579d" name="a4dfcf7230a9827417d8c985feee1579d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dfcf7230a9827417d8c985feee1579d">&#9670;&#160;</a></span>AddNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tSubNode * <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::AddNode </td>
          <td>(</td>
          <td class="paramtype">tSubNode &amp;&#160;</td>
          <td class="paramname"><em>nodeRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>updatemesh</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a19ed489278cbdcec8e2516f544aa8000" name="a19ed489278cbdcec8e2516f544aa8000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ed489278cbdcec8e2516f544aa8000">&#9670;&#160;</a></span>AddNodeAt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tSubNode * <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::AddNodeAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classt_array.html">tArray</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#a19ed489278cbdcec8e2516f544aa8000">tMesh::AddNodeAt</a></p>
<p>add a node with referenced coordinates to mesh; this fn duplicates functionality of AddNode</p>
<p>Created: SL fall, '97 Modified: NG summer, '98 to deal with layer interpolation </p>

</div>
</div>
<a id="a2ff1becca6714d7233aa11ea529afd2e" name="a2ff1becca6714d7233aa11ea529afd2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff1becca6714d7233aa11ea529afd2e">&#9670;&#160;</a></span>AddNodesAround()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::AddNodesAround </td>
          <td>(</td>
          <td class="paramtype">tSubNode *&#160;</td>
          <td class="paramname"><em>centerNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#a2ff1becca6714d7233aa11ea529afd2e">tMesh::AddNodesAround</a></p>
<p>Densifies the mesh in the vicinity of a given node (centerNode) by adding new nodes at the coordinates of the centerNode's Voronoi vertices.</p>
<p>Properties of each node are initially those of the centerNode, except z which is computed using interpolation by getVoronoiVertexXYZList. </p><pre class="fragment">Inputs: centerNode -- the node around which to add new nodes
        time -- simulation time (for layer updating)
Data members updated: Mesh elements &amp; their geometry
Called by:  called outside of tMesh by routines that handle
            adaptive meshing
Calls: AddNode, UpdateMesh, tNode::getVoronoiVertexXYZList
Created: GT, for dynamic mesh updating, Feb 2000  
</pre> 
</div>
</div>
<a id="afe8545217f484745be3bfb04ab288028" name="afe8545217f484745be3bfb04ab288028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8545217f484745be3bfb04ab288028">&#9670;&#160;</a></span>allocateNodeTable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::allocateNodeTable </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c03a0d5246105efdb77cc6853c57faf" name="a0c03a0d5246105efdb77cc6853c57faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c03a0d5246105efdb77cc6853c57faf">&#9670;&#160;</a></span>CalcVAreas()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::CalcVAreas</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#a0c03a0d5246105efdb77cc6853c57faf">tMesh::CalcVAreas</a></p>
<p>Computes Voronoi area for each active (non-boundary) node in the mesh (Voronoi area is only defined for interior nodes). Accomplishes this by calling ComputeVoronoiArea for each node. </p>

</div>
</div>
<a id="a355454e97230dfb15b441c7453032cb1" name="a355454e97230dfb15b441c7453032cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a355454e97230dfb15b441c7453032cb1">&#9670;&#160;</a></span>CalcVoronoiEdgeLengths()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::CalcVoronoiEdgeLengths</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#a355454e97230dfb15b441c7453032cb1">tMesh::CalcVoronoiEdgeLengths</a></p>
<p>Updates the length of the Voronoi cell edge associated with each triangle edge. Because complementary edges are stored pairwise on the edge list, we can save computation time by only computing the vedglen once for the first of the pair, then assigning it to the second. For boundary triangle edges, the corresponding Voronoi edge is infinitely long, so the calculation is only done for interior (active) edges. </p>

</div>
</div>
<a id="a6b2549f47aad9659b507aca8f30ff66f" name="a6b2549f47aad9659b507aca8f30ff66f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2549f47aad9659b507aca8f30ff66f">&#9670;&#160;</a></span>ChangePointOrder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::ChangePointOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classt_input_file.html">tInputFile</a> &amp;&#160;</td>
          <td class="paramname"><em>infile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classt_list.html">tList</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>XY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html">tMesh</a>: <a class="el" href="classt_mesh.html#a6b2549f47aad9659b507aca8f30ff66f">ChangePointOrder( tInputFile &amp;, tList&lt;double&gt;)</a></p>
<p>Function created to change the order in a points file for those interior points exclusively connected to exterior nodes. This function becomes unnecessary if an inner ring is included in the TIN Mesh. </p>

</div>
</div>
<a id="ab5468c8f79d9591088d6671cc7b46192" name="ab5468c8f79d9591088d6671cc7b46192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5468c8f79d9591088d6671cc7b46192">&#9670;&#160;</a></span>CheckForFlip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::CheckForFlip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classt_triangle.html">tTriangle</a> *&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#ab5468c8f79d9591088d6671cc7b46192">tMesh::CheckForFlip</a></p>
<p>Checks whether edge between two triangles should be flipped; may either check, flip, and report, or just check and report. Checks whether the present angle or the possible angle is greater. Greater angle wins. Also uses flip variable to determine whether to use newx, newy, or x, y. </p><pre class="fragment">Inputs: tri -- ptr to the triangle to be tested
        nv -- the number of the vertex opposite the edge that
              might be flipped (0, 1, or 2)
        flip -- flag indicating whether we want to actually flip
                the edge if needed (TRUE) or simply test the flip
                condition for a point that is about to be moved to
                a new position (FALSE)
Returns: 1 if flip is needed, 0 otherwise
Modifies: edge may be flipped
Called by: AddNode, AddNodeAt, CheckLocallyDelaunay,
           tStreamMeander::CheckBrokenFlowedge
Calls: PointsCCW, FlipEdge, TriPasses                                             
</pre> 
</div>
</div>
<a id="a203caceeb74bd9d0c8d38ce848f1ee6a" name="a203caceeb74bd9d0c8d38ce848f1ee6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a203caceeb74bd9d0c8d38ce848f1ee6a">&#9670;&#160;</a></span>CheckLocallyDelaunay()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::CheckLocallyDelaunay</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#a203caceeb74bd9d0c8d38ce848f1ee6a">tMesh::CheckLocallyDelaunay</a></p>
<p>Updates the triangulation after moving some points. Only uses x and y values, which have already been updated in MoveNodes (frmr PreApply). MoveNodes SHOULD BE CALLED BEFORE THIS FUNCTION IS CALLED</p>
<p>The logic here is somewhat complicated. Here is GT's understanding of it (Stephen, can you confirm?):</p>
<ol type="1">
<li>We create a list of triangles that have at least one vertex that has moved (triPtrList) and which therefore might no longer be Delaunay.</li>
<li>For each of these, we do a flip check across each face. Before doing so, however, we find the triangle on the triPtrList, if any, that comes just before this neighboring triangle. If the edge between the triangles gets flipped, both the triangles will be deleted and recreated on the master triangle list; thus, we will need to delete both affected triangles from triPtrList and re-add the new ones.</li>
<li>If a flip occurs, remove the opposite triangle pointer from the list if needed in order to prevent a dangling pointer. The two affected triangles will have been replaced by new triangles which are now at the back of the master triangle list; add these two to the triPtrList to be rechecked, and break out of the vertex loop.</li>
<li>Remove the triangle in question from the head of the triPtrList (regardless of whether it was flipped or not; if it was, its a dangling pointer; if not, it is Delaunay and we no longer need worry about it)</li>
<li>Continue until there are no more triangles to be checked. </li>
</ol>

</div>
</div>
<a id="aff5058ee5d62594eac66b1ed67cdc538" name="aff5058ee5d62594eac66b1ed67cdc538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff5058ee5d62594eac66b1ed67cdc538">&#9670;&#160;</a></span>CheckMeshConsistency() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::CheckMeshConsistency </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>boundaryCheckFlag</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#aff5058ee5d62594eac66b1ed67cdc538">tMesh::CheckMeshConsistency</a></p>
<p>Performs a series of tests to make sure the mesh connectivity is correct. Should be called immediately after reading in a user-defined mesh</p>
<p>The consistency checks include the following:</p>
<p>1) Each edge:</p><ul>
<li>Has valid origin and destination pointers</li>
<li>Has a valid counter-clockwise edge, which shares the same origin but not the same destination</li>
<li>Is paired with its complement in the list</li>
</ul>
<p>2) Each node:</p><ul>
<li>Points to a valid edge which has the node as its origin</li>
<li>If the node is not a boundary, it has at least one neighbor that is not a closed boundary (unless boundaryCheckFlag is FALSE).</li>
<li>Has a consistent spoke list (ie, you can go around the spokes and get back to where you started)</li>
</ul>
<p>3) Each triangle:</p><ul>
<li>Has 3 valid points and edges</li>
<li>Each edge Ei has Pi as its origin and P((i+2)%3) as its destination</li>
<li>If an opposite triangle Ti exists, points P((i+1)%3) and P((i+2)%3) are the same as points PO((n+2)%3) and PO((n+1)%3) in the opposite triangle, where PO denotes a point in the opposite triangle and n is the vertex ID (0, 1, or 2) of the point in the opposite triangle that is opposite from the shared face.</li>
<li><p class="startli">If an opposite triange Ti does not exist, points P((i+1)%3) and and P((i+2)%3) should both be boundary points.</p>
<p class="startli">Parameters: boundaryCheckFlag &ndash; defaults to TRUE; if FALSE, node connection to open node or open boundary isn't tested </p>
</li>
</ul>

</div>
</div>
<a id="a8cbbf53e424f2aeee81467e11c200480" name="a8cbbf53e424f2aeee81467e11c200480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cbbf53e424f2aeee81467e11c200480">&#9670;&#160;</a></span>CheckMeshConsistency() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::CheckMeshConsistency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classt_input_file.html">tInputFile</a> &amp;&#160;</td>
          <td class="paramname"><em>infile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>boundaryCheckFlag</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>tMesh::CheckMeshConsistency(tInputFile) see also previous routine CheckMeshconsistency()</p>
<p>Perform the same checking that the previous CheckMeshconsitency() In the case of real data from dems, the constructed mesh may have some points nodes surrounded by closed boundary nodes. That comes from the succession of the points in the input file, those points have to be at the end of the file read by MakeMeshFromPoints and may be at the second run be removed. </p>

</div>
</div>
<a id="ae380b45bd056286aca9911413adf8431" name="ae380b45bd056286aca9911413adf8431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae380b45bd056286aca9911413adf8431">&#9670;&#160;</a></span>CheckTriEdgeIntersect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::CheckTriEdgeIntersect</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#ae380b45bd056286aca9911413adf8431">tMesh::CheckTriEdgeIntersect</a> </p><pre class="fragment">  This function implements node movement.
  We want to know if the moving point has passed beyond the polygon
  defined by its spoke edges; if it has, then we will have edges
  intersecting one another. In the case where the point has simply
  passed into one of the 'opposite' triangles, then we can just do a
  flip operation. In the other case, the remedial action is much more
  complicated, so we just delete the point and add it again.
</pre> 
</div>
</div>
<a id="ac3c4c76a689aac700b82d9cc0ae2dc49" name="ac3c4c76a689aac700b82d9cc0ae2dc49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c4c76a689aac700b82d9cc0ae2dc49">&#9670;&#160;</a></span>DeleteEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::DeleteEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classt_edge.html">tEdge</a> *&#160;</td>
          <td class="paramname"><em>edgePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#ac3c4c76a689aac700b82d9cc0ae2dc49">tMesh::DeleteEdge</a></p>
<p>Deletes an edge from the mesh, returning 1 if deletion succeeds and 0 if not. Starts by calling ExtricateEdge to detach the edge from the other mesh elements. This function actually deletes two directed edges: edgePtr and its complement.</p>
<p>Inputs: edgePtr &ndash; ptr to the edge to be deleted Returns: 1 if successful, 0 if not Calls: ExtricateEdge </p>

</div>
</div>
<a id="a4f26b4897c91d04a65b9a496c9b80fd7" name="a4f26b4897c91d04a65b9a496c9b80fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f26b4897c91d04a65b9a496c9b80fd7">&#9670;&#160;</a></span>DeleteNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::DeleteNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classt_list_node.html">tListNode</a>&lt; tSubNode &gt; *&#160;</td>
          <td class="paramname"><em>nodPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>repairFlag</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#a4f26b4897c91d04a65b9a496c9b80fd7">tMesh::DeleteNode</a>( <a class="el" href="classt_list_node.html">tListNode&lt;tSubNode&gt;</a> *, int =1 ) (see DeleteNode( tSubNode *, int =1 ) below) </p>

</div>
</div>
<a id="a46dc5c91f0cff874022a5e483e14dd7e" name="a46dc5c91f0cff874022a5e483e14dd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46dc5c91f0cff874022a5e483e14dd7e">&#9670;&#160;</a></span>DeleteNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::DeleteNode </td>
          <td>(</td>
          <td class="paramtype">tSubNode *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>repairFlag</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#a4f26b4897c91d04a65b9a496c9b80fd7">tMesh::DeleteNode</a>( tSubNode *, int =1 )</p>
<p>Deletes a node from the mesh. This is done by first calling ExtricateNode to detach the node by removing its edges and their associated triangles, then removing the node from the nodeList. Normally, RepairMesh is then called to retriangulate the "hole" left behind in the mesh. (However, if the node was on the hull of the mesh there's no "hole" to fix &mdash; the caller is assumed to be smart enough to recognize this case and let us know about it by setting repairFlag to kNoRepair. This is the case, for example, when deleting the nodes that form a "supertriangle" as in MakeMeshFromPoints).</p>
<p>Once the mesh is repaired, the nodes are renumbered and as a safety measure for debugging/testing purposes, UpdateMesh is called.</p>
<p>Data mbrs modified: nnodes, nedges, and ntri are updated; the node is deleted from nodeList; other edges &amp; triangles are removed and/or modified by ExtricateNode and RepairMesh (qv) Calls: <a class="el" href="classt_mesh.html#ae9a397275be803052818e0ee8c5d6ab6">tMesh::ExtricateNode</a>, <a class="el" href="classt_mesh.html#aa156c800db8793912a3020e752f76f13">tMesh::RepairMesh</a>, plus utility member functions of <a class="el" href="classt_node.html">tNode</a>, <a class="el" href="classt_mesh_list.html">tMeshList</a>, etc. Returns: error code: 0 if ExtricateNode or RepairMesh fails, 1 otherwise. </p>

</div>
</div>
<a id="aa91878b784d08004a008a6d3721a47f6" name="aa91878b784d08004a008a6d3721a47f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91878b784d08004a008a6d3721a47f6">&#9670;&#160;</a></span>deleteNodeTable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::deleteNodeTable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abad291447852bc92ff12cca1d00b7c77" name="abad291447852bc92ff12cca1d00b7c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad291447852bc92ff12cca1d00b7c77">&#9670;&#160;</a></span>DeleteTriangle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::DeleteTriangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classt_triangle.html">tTriangle</a> *&#160;</td>
          <td class="paramname"><em>triPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#abad291447852bc92ff12cca1d00b7c77">tMesh::DeleteTriangle</a></p>
<p>Deletes a triangle from the mesh. Starts off with a call to ExtricateTriangle to detach the triangle from other mesh elements, after which the triangle is at the front of the triangle list, from whence it is then deleted.</p>
<p>Inputs: triPtr &ndash; ptr to the triangle to be deleted Returns: 1 if successful, 0 if not Calls: ExtricateTriangle Called by: DeleteEdge, AddNode, AddNodeAt </p>

</div>
</div>
<a id="a4055127efa626a0d087f0a7377ac0b6a" name="a4055127efa626a0d087f0a7377ac0b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4055127efa626a0d087f0a7377ac0b6a">&#9670;&#160;</a></span>DumpEdges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::DumpEdges</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#a4055127efa626a0d087f0a7377ac0b6a">DumpEdges()</a>, <a class="el" href="classt_mesh.html#ae372729b6c2bcee73721193f0ee0d18b">DumpSpokes()</a>, <a class="el" href="classt_mesh.html#a556a97b81eb290243a19e3e0d0f635ff">DumpTriangles()</a>, <a class="el" href="classt_mesh.html#a79ac4616c0e776d707ffb4d4d615b456">DumpNodes()</a>: debugging routines which simply write out information pertaining to the mesh; <a class="el" href="classt_mesh.html#a79ac4616c0e776d707ffb4d4d615b456">DumpNodes()</a> calls DumpSpokes for each node; <a class="el" href="classt_mesh.html#ae372729b6c2bcee73721193f0ee0d18b">DumpSpokes()</a> takes a pointer to a node as an argument. </p>

</div>
</div>
<a id="a79ac4616c0e776d707ffb4d4d615b456" name="a79ac4616c0e776d707ffb4d4d615b456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ac4616c0e776d707ffb4d4d615b456">&#9670;&#160;</a></span>DumpNodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::DumpNodes</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae372729b6c2bcee73721193f0ee0d18b" name="ae372729b6c2bcee73721193f0ee0d18b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae372729b6c2bcee73721193f0ee0d18b">&#9670;&#160;</a></span>DumpSpokes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::DumpSpokes </td>
          <td>(</td>
          <td class="paramtype">tSubNode *&#160;</td>
          <td class="paramname"><em>cn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a556a97b81eb290243a19e3e0d0f635ff" name="a556a97b81eb290243a19e3e0d0f635ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a556a97b81eb290243a19e3e0d0f635ff">&#9670;&#160;</a></span>DumpTriangles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::DumpTriangles</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2e45ad3f47553de38d256c7e2928653" name="ae2e45ad3f47553de38d256c7e2928653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e45ad3f47553de38d256c7e2928653">&#9670;&#160;</a></span>ExtricateEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::ExtricateEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classt_edge.html">tEdge</a> *&#160;</td>
          <td class="paramname"><em>edgePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#ae2e45ad3f47553de38d256c7e2928653">tMesh::ExtricateEdge</a></p>
<p>Here we detach an edge and its complement from the surrounding mesh elements prior to deletion. Adjacent triangle(s) are also deleted via a call to DeleteTriangle. Calls the virtual node function WarnSpokeLeaving to signal the affected nodes to take appropriate action. (Appropriate action might depend on the application; that's why it is a virtual function that can be handled by any descendents of <a class="el" href="classt_node.html">tNode</a>). The two complementary edges are then placed at the back of the edge list, where DeleteEdge can conveniently find them.</p>
<p>Inputs: edgePtr &ndash; ptr to the edge to be deleted Returns: 1 if successful, 0 otherwise Calls: DeleteTriangle, &lt;tSubNode&gt;::WarnSpokeLeaving </p>

</div>
</div>
<a id="ae9a397275be803052818e0ee8c5d6ab6" name="ae9a397275be803052818e0ee8c5d6ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a397275be803052818e0ee8c5d6ab6">&#9670;&#160;</a></span>ExtricateNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::ExtricateNode </td>
          <td>(</td>
          <td class="paramtype">tSubNode *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classt_ptr_list.html">tPtrList</a>&lt; tSubNode &gt; &amp;&#160;</td>
          <td class="paramname"><em>nbrList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#ae9a397275be803052818e0ee8c5d6ab6">tMesh::ExtricateNode</a></p>
<p>Detaches a node from the mesh by deleting all of its edges (which in turn removes the affected triangles). Returns a list of the node's former neighbors by modifying the nbrList input parameter. Also returns a code that indicates failure if the node still has a non-empty spoke list after edge deletion.</p>
<p>Data mbrs modified: nnodes; edges and triangles are removed from edgeList and triList Calls: <a class="el" href="classt_mesh.html#ac3c4c76a689aac700b82d9cc0ae2dc49">tMesh::DeleteEdge</a> and utility member functions of <a class="el" href="classt_node.html">tNode</a>, <a class="el" href="classt_ptr_list.html">tPtrList</a>, <a class="el" href="classt_ptr_list_iter.html">tPtrListIter</a> Output: list of node's (former) neighbors, in nbrList Returns: 1 if all edges successfully deleted, 0 if not Calls: DeleteEdge Assumes: <br  />
 Notes: Created: SL fall, '97 Modifications: if node is a closed boundary, any of its neighbors that are non-boundaries are switched to closed boundaries, so that nodes along the edge of the domain (including nodes of a "supertriangle" used in MakeMeshFromPoints) may be removed without causing errors, GT 4/98 </p>

</div>
</div>
<a id="a843e3ff646d320a57acc5ff736cab517" name="a843e3ff646d320a57acc5ff736cab517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843e3ff646d320a57acc5ff736cab517">&#9670;&#160;</a></span>ExtricateTriangle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::ExtricateTriangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classt_triangle.html">tTriangle</a> *&#160;</td>
          <td class="paramname"><em>triPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#a843e3ff646d320a57acc5ff736cab517">tMesh::ExtricateTriangle</a></p>
<p>Detaches a triangle from surrounding mesh elements and places it at the head of the triangle list, where it can be easily deleted by DeleteTriangle.</p>
<p>Inputs: triPtr &ndash; ptr to the triangle to be extricated Returns: 1 if successful, 0 if not Called by: DeleteTriangle </p>

</div>
</div>
<a id="a39476cfe04376ab3494c764cc0df0a09" name="a39476cfe04376ab3494c764cc0df0a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39476cfe04376ab3494c764cc0df0a09">&#9670;&#160;</a></span>FlipEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::FlipEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classt_triangle.html">tTriangle</a> *&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classt_triangle.html">tTriangle</a> *&#160;</td>
          <td class="paramname"><em>triop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#a39476cfe04376ab3494c764cc0df0a09">tMesh::FlipEdge</a></p>
<p>Flips the edge pair between two adjacent triangle to re-establish Delaunay-ness.</p>
<p>Note on notation in flip edge: </p><pre class="fragment">          d
         /|\
 tri-&gt;  / | \ &lt;-triop
       /  |  \
      a   |   c
       \  |  /
        \ | /
         \|/
          b
  Edge bd will be removed
  and an edge ac will be made.
  nbrList contains the points a, b, c, d
</pre><p> Inputs: tri, triop &ndash; the triangles sharing the edge to be flipped nv &ndash; the number of tri's vertex (0, 1 or 2) opposite the edge (ie, point a) nvop &ndash; the number of triop's vertex (0, 1 or 2) opposite the edge (ie, point c) Calls: DeleteEdge, AddEdgeAndMakeTriangle, MakeTriangle Called by: CheckForFlip, CheckTriEdgeIntersect </p>

</div>
</div>
<a id="a86337d3cf4ebc31b178f5dbbf51f76dc" name="a86337d3cf4ebc31b178f5dbbf51f76dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86337d3cf4ebc31b178f5dbbf51f76dc">&#9670;&#160;</a></span>getEdgeComplement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classt_edge.html">tEdge</a> * <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::getEdgeComplement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classt_edge.html">tEdge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#a86337d3cf4ebc31b178f5dbbf51f76dc">tMesh::getEdgeComplement</a></p>
<p>Returns the complement of <em>edge</em> (i.e., the edge that shares the same endpoints but points in the opposite direction). To find the complement, it exploits the fact that complementary pairs of edges are stored together on the edge list, with the first of each pair having an even-numbered ID and the second having an odd-numbered ID.</p>
<p>Modifications: gt replaced 2nd IF with ELSE to avoid compiler warning </p>

</div>
</div>
<a id="a42828f1f1dd4bd72cf811136ee82cb67" name="a42828f1f1dd4bd72cf811136ee82cb67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42828f1f1dd4bd72cf811136ee82cb67">&#9670;&#160;</a></span>getEdgeList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classt_mesh_list.html">tMeshList</a>&lt; <a class="el" href="classt_edge.html">tEdge</a> &gt; * <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::getEdgeList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a688bd68a729d729d62fe008b493e233d" name="a688bd68a729d729d62fe008b493e233d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688bd68a729d729d62fe008b493e233d">&#9670;&#160;</a></span>getNodeFromID()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tSubNode * <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::getNodeFromID </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a100711530a0f6b2b2d8e70f307da34c7" name="a100711530a0f6b2b2d8e70f307da34c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100711530a0f6b2b2d8e70f307da34c7">&#9670;&#160;</a></span>getNodeList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classt_mesh_list.html">tMeshList</a>&lt; tSubNode &gt; * <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::getNodeList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a77943f86a3c14f52bf1aee5932050b5f" name="a77943f86a3c14f52bf1aee5932050b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77943f86a3c14f52bf1aee5932050b5f">&#9670;&#160;</a></span>getTriList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classt_list.html">tList</a>&lt; <a class="el" href="classt_triangle.html">tTriangle</a> &gt; * <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::getTriList</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae06a218520980fd50da2646452d1646c" name="ae06a218520980fd50da2646452d1646c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06a218520980fd50da2646452d1646c">&#9670;&#160;</a></span>getUnsortList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classt_mesh_list.html">tMeshList</a>&lt; tSubNode &gt; * <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::getUnsortList</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html">tMesh</a> "get" functions </p>

</div>
</div>
<a id="a61eaa1703ddd3329047402d428dd2e44" name="a61eaa1703ddd3329047402d428dd2e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61eaa1703ddd3329047402d428dd2e44">&#9670;&#160;</a></span>IntersectsAnyEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classt_edge.html">tEdge</a> * <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::IntersectsAnyEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classt_edge.html">tEdge</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad96748c5d7afab4ba072abe8b161a85a" name="ad96748c5d7afab4ba072abe8b161a85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96748c5d7afab4ba072abe8b161a85a">&#9670;&#160;</a></span>LocateNewTriangle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classt_triangle.html">tTriangle</a> * <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::LocateNewTriangle </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#ad96748c5d7afab4ba072abe8b161a85a">tMesh::LocateNewTriangle</a></p>
<p>Called by: AddNodeAt </p>

</div>
</div>
<a id="adadcf7237806076b4b6d28b374647caf" name="adadcf7237806076b4b6d28b374647caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adadcf7237806076b4b6d28b374647caf">&#9670;&#160;</a></span>LocateTriangle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classt_triangle.html">tTriangle</a> * <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::LocateTriangle </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#adadcf7237806076b4b6d28b374647caf">tMesh::LocateTriangle</a></p>
<p>Locates the triangle in which point (x,y) falls. The algorithm exploits the fact that the 3 triangle points are always in counter-clockwise order, so that the point is contained within a given triangle (p0,p1,p2) if and only if the point lies to the left of vectors p0-&gt;p1, p1-&gt;p2, and p2-&gt;p0. Here's how it works: 1 - start with a given triangle (currently first on the list, but a smarter initial guess could be used &ndash; TODO) 2 - lv is the number of successful left-hand checks found so far: initialize it to zero 3 - check whether (x,y) lies to the left of p(lv)-&gt;p((lv+1)%3) 4 - if so, increment lv by one (ie, move on to the next vector) 5 - if not, (x,y) is to the right of the current face, so move to the triangle that lies opposite that face and reset lv to zero 6 - continue steps 3-5 until lv==3, which means that we've found our triangle. 7 - so far, a point "on the line", i.e., colinear w/ two of the three points, still passes; that's OK unless that line is on the boundary, so we need to check</p>
<p>Input: x, y &ndash; coordinates of the point Modifies: (nothing) Returns: a pointer to the triangle that contains (x,y) Assumes: the point is contained within one of the current triangles </p>

</div>
</div>
<a id="aeac7892985d902ac09e63147d8d59147" name="aeac7892985d902ac09e63147d8d59147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac7892985d902ac09e63147d8d59147">&#9670;&#160;</a></span>MakeCCWEdges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::MakeCCWEdges</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7f2b6c261b817daccf4f5ca5f6f4bd9" name="aa7f2b6c261b817daccf4f5ca5f6f4bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f2b6c261b817daccf4f5ca5f6f4bd9">&#9670;&#160;</a></span>MakeHexMeshFromArcGrid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::MakeHexMeshFromArcGrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classt_input_file.html">tInputFile</a> &amp;&#160;</td>
          <td class="paramname"><em>infile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#aa7f2b6c261b817daccf4f5ca5f6f4bd9">tMesh::MakeHexMeshFromArcGrid</a></p>
<p>Routine to make irregular mesh from regular Arc grid by randomly sampling the grid such that the average resolution of the irregular mesh is equal to that of the Arc grid. Designed to read from a grid containing points either within an already isolated basin or containing "no data".</p>
<p>Calls: <a class="el" href="classt_input_file.html#a2a2d2600565a0124f37f7bff7608e28d">tInputFile::ReadItem</a>, <a class="el" href="classt_mesh.html#aeac7892985d902ac09e63147d8d59147">MakeCCWEdges()</a>, <a class="el" href="classt_mesh.html#a79f4924148c66d771a3bd47ef87fef32">UpdateMesh()</a>, <a class="el" href="classt_mesh.html#aff5058ee5d62594eac66b1ed67cdc538">CheckMeshConsistency()</a> Parameters: infile &ndash; main parameter input file </p>

</div>
</div>
<a id="ac1d76f5e10736bd3678bd73a6d7a28ad" name="ac1d76f5e10736bd3678bd73a6d7a28ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d76f5e10736bd3678bd73a6d7a28ad">&#9670;&#160;</a></span>MakeLayersFromInputData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::MakeLayersFromInputData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classt_input_file.html">tInputFile</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd5d92b3ad8bfe92e0e0ffede3cb742d" name="abd5d92b3ad8bfe92e0e0ffede3cb742d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5d92b3ad8bfe92e0e0ffede3cb742d">&#9670;&#160;</a></span>MakeMeshFromInputData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::MakeMeshFromInputData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classt_input_file.html">tInputFile</a> &amp;&#160;</td>
          <td class="paramname"><em>infile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#abd5d92b3ad8bfe92e0e0ffede3cb742d">tMesh::MakeMeshFromInputData</a></p>
<p>Constructs <a class="el" href="classt_list_input_data.html">tListInputData</a> object and makes mesh from data in that object.</p>
<p>Calls: <a class="el" href="classt_list_input_data.html">tListInputData( infile )</a>, <a class="el" href="classt_mesh.html#a79f4924148c66d771a3bd47ef87fef32">UpdateMesh()</a>, <a class="el" href="classt_mesh.html#aff5058ee5d62594eac66b1ed67cdc538">CheckMeshConsistency()</a> Inputs: infile &ndash; main input file from which various items are read </p>

</div>
</div>
<a id="a86514e02499ed0f497c6e3e174f5625c" name="a86514e02499ed0f497c6e3e174f5625c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86514e02499ed0f497c6e3e174f5625c">&#9670;&#160;</a></span>MakeMeshFromMeshBuilder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::MakeMeshFromMeshBuilder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classt_input_file.html">tInputFile</a> &amp;&#160;</td>
          <td class="paramname"><em>infile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>tMesh::MakeMeshFromMeshBuilder( infile )</p>
<p>Similar to <a class="el" href="classt_mesh.html#a2ec739b48323a5be15c27ff984958474">tMesh::MakeMeshFromTriangulator</a> using Tipper's triangulation algorithm within the separate MeshBuilder code. This mesh generator is for large data sets.</p>
<p>Reads mesh which was already checked and enhanced with voronoi information from data files. Reads in basic <a class="el" href="classt_node.html">tNode</a> information but creates a <a class="el" href="classt_c_node.html">tCNode</a>. </p>

</div>
</div>
<a id="a4f9f870682626c4cd09d057a601654c0" name="a4f9f870682626c4cd09d057a601654c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f9f870682626c4cd09d057a601654c0">&#9670;&#160;</a></span>MakeMeshFromPoints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::MakeMeshFromPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classt_input_file.html">tInputFile</a> &amp;&#160;</td>
          <td class="paramname"><em>infile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#a4f9f870682626c4cd09d057a601654c0">tMesh::MakeMeshFromPoints</a></p>
<p>Constructs a mesh from a given set of (x,y,z,b) points.</p>
<p>The format of the file containing points is: NP X0 Y0 Z0 B0 X1 Y1 Z1 B1 ...etc. where NP is the number of points in the file, X, Y, and Z are x, y, and z coords, and B is the boundary code.</p>
<p>Calls: <a class="el" href="classt_input_file.html#a2a2d2600565a0124f37f7bff7608e28d">tInputFile::ReadItem</a>, <a class="el" href="classt_mesh.html#aeac7892985d902ac09e63147d8d59147">MakeCCWEdges()</a>, <a class="el" href="classt_mesh.html#a79f4924148c66d771a3bd47ef87fef32">UpdateMesh()</a>, <a class="el" href="classt_mesh.html#aff5058ee5d62594eac66b1ed67cdc538">CheckMeshConsistency()</a> Parameters: infile &ndash; main parameter input file </p>

</div>
</div>
<a id="a83a72a956b713e3ce4cbbb1e3e19604c" name="a83a72a956b713e3ce4cbbb1e3e19604c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a72a956b713e3ce4cbbb1e3e19604c">&#9670;&#160;</a></span>MakeMeshFromScratch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::MakeMeshFromScratch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classt_input_file.html">tInputFile</a> &amp;&#160;</td>
          <td class="paramname"><em>infile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>tMesh::MakeMeshFromScratch( infile )</p>
<p>Formerly <a class="el" href="classt_mesh.html">tMesh( infile )</a>. Makes mesh from scratch; reads parameters from input file to get mesh size, spacing, method of point placement.</p>
<p>Could probably be done more gracefully, but here's how it does it: 1) makes boundary nodes and edges between them; 2) makes triangulation with only boundary nodes; 3) adds the rest of the nodes one at a time, i.e., triangulation redone for each node added.</p>
<p>Created: 2/11/98, SL Calls: <a class="el" href="classt_mesh.html#aeac7892985d902ac09e63147d8d59147">MakeCCWEdges()</a>, <a class="el" href="classt_mesh.html#a79f4924148c66d771a3bd47ef87fef32">UpdateMesh()</a>, <a class="el" href="classt_mesh.html#aff5058ee5d62594eac66b1ed67cdc538">CheckMeshConsistency()</a> Parameters: xGrid, yGrid, boundType, mElev, ptPlace, delGrid, numPts, upperZ, xout, yout</p>
<p>TYP_BOUND keyword used to read type of open boundary: 0 = corner outlet (lower left) 1 = one open side (lower) 2 = two opposite sides (upper and lower) 3 = all sides 4 = specify outlet coordinates</p>
<p>OPT_PT_PLACE keyword used to read method of point placement: 0 = uniform grid; 1 = perturbed grid; 2 = random scatter; </p>

</div>
</div>
<a id="a2ec739b48323a5be15c27ff984958474" name="a2ec739b48323a5be15c27ff984958474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec739b48323a5be15c27ff984958474">&#9670;&#160;</a></span>MakeMeshFromTriangulator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::MakeMeshFromTriangulator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classt_input_file.html">tInputFile</a> &amp;&#160;</td>
          <td class="paramname"><em>infile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a18344f25afa738e9128de72ca28ceb24" name="a18344f25afa738e9128de72ca28ceb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18344f25afa738e9128de72ca28ceb24">&#9670;&#160;</a></span>MakePointFromFileArcInfo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::MakePointFromFileArcInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classt_input_file.html">tInputFile</a> &amp;&#160;</td>
          <td class="paramname"><em>infile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#a18344f25afa738e9128de72ca28ceb24">tMesh::MakePointFromFileArcInfo</a></p>
<p>Routine to convert ArcInfo files .net (NODES, EDGES, TRIANGLES) describing a TIN (generated by ungeneratetin function) to a file of points ( x, y, z, boundary) readable by the function MakeMeshFromPoints</p>
<p>calls: <a class="el" href="classt_input_file.html#a2a2d2600565a0124f37f7bff7608e28d">tInputFile::ReadItem</a> Created: 10/2000 VT </p>

</div>
</div>
<a id="a624048904530b99629022ad95a6adddc" name="a624048904530b99629022ad95a6adddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624048904530b99629022ad95a6adddc">&#9670;&#160;</a></span>MakePointFromFileArcInfoGen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::MakePointFromFileArcInfoGen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classt_input_file.html">tInputFile</a> &amp;&#160;</td>
          <td class="paramname"><em>infile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#a624048904530b99629022ad95a6adddc">tMesh::MakePointFromFileArcInfoGen</a></p>
<p>Routine to convert ArcInfo files .lin and .pnt (LINES and POINTS) describing a TIN (generated by ungeneratetin function using generate) to a file of points ( x, y, z, boundary) readable by the function MakeMeshFromPoints. Used in cases where the stream network must be inputed as a separate boundary code.</p>
<p>calls: <a class="el" href="classt_input_file.html#a2a2d2600565a0124f37f7bff7608e28d">tInputFile::ReadItem</a> </p>

</div>
</div>
<a id="aae28a17ad899ae2f0f4f91df69e15f62" name="aae28a17ad899ae2f0f4f91df69e15f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae28a17ad899ae2f0f4f91df69e15f62">&#9670;&#160;</a></span>MakeRandomPointsFromArcGrid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::MakeRandomPointsFromArcGrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classt_input_file.html">tInputFile</a> &amp;&#160;</td>
          <td class="paramname"><em>infile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#aae28a17ad899ae2f0f4f91df69e15f62">tMesh::MakeRandomPointsFromArcGrid</a></p>
<p>Routine to make irregular mesh from regular Arc grid by randomly sampling the grid such that the average resolution of the irregular mesh is equal to that of the Arc grid.</p>
<p>Calls: <a class="el" href="classt_input_file.html#a2a2d2600565a0124f37f7bff7608e28d">tInputFile::ReadItem</a>, <a class="el" href="classt_mesh.html#aeac7892985d902ac09e63147d8d59147">MakeCCWEdges()</a>, <a class="el" href="classt_mesh.html#a79f4924148c66d771a3bd47ef87fef32">UpdateMesh()</a>, <a class="el" href="classt_mesh.html#aff5058ee5d62594eac66b1ed67cdc538">CheckMeshConsistency()</a> Parameters: infile &ndash; main parameter input file </p>

</div>
</div>
<a id="a656c98c2bd4f8366c991cbe1a21f1309" name="a656c98c2bd4f8366c991cbe1a21f1309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a656c98c2bd4f8366c991cbe1a21f1309">&#9670;&#160;</a></span>MakeTriangle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::MakeTriangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classt_ptr_list.html">tPtrList</a>&lt; tSubNode &gt; &amp;&#160;</td>
          <td class="paramname"><em>nbrList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classt_ptr_list_iter.html">tPtrListIter</a>&lt; tSubNode &gt; &amp;&#160;</td>
          <td class="paramname"><em>nbrIter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#a656c98c2bd4f8366c991cbe1a21f1309">tMesh::MakeTriangle</a></p>
<p>Function to make triangle and add it to mesh; called when all necessary nodes and edges already exist, i.e., the triangle exists geometrically but not as a "triangle" member of the data structure. Checks to make sure points are CCW. Resets triangle IDs at end (necessary?). This function is relatively messy and complicated but is extensively commented below.</p>
<p>Inputs: a tPtrList&lt;tSubNode&gt; of nodes in triangle; a <a class="el" href="classt_ptr_list_iter.html">tPtrListIter</a> object, the iterator of the latter list; edge is added between node currently pointed to by iterator and the node-after-next. List must contain three, and only three, members and be circular. Created: SL fall, '97</p>
<p>Modifications:</p><ul>
<li>mSearchOriginTriPtr is reset to point to the newly added triangle in an attempt to speed up triangle searches, especially during mesh creation. GT 1/2000 </li>
</ul>

</div>
</div>
<a id="a0d673bc9803fa274d638f2fd098d19d5" name="a0d673bc9803fa274d638f2fd098d19d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d673bc9803fa274d638f2fd098d19d5">&#9670;&#160;</a></span>MoveNodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::MoveNodes </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em> = <code>0.0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#a0d673bc9803fa274d638f2fd098d19d5">tMesh::MoveNodes</a></p>
<p>Once the new coordinates for moving nodes have been established, this function is called to update the node coordinates, modify the triangulation as needed, and update the mesh geometry (Voronoi areas, edge lengths, etc) through a series of calls to helper functions.</p>
<p>Interpolation is performed on nodes with layering (3D vertical component) here. TODO: make interpolation general, perhaps by defining a virtual <a class="el" href="classt_node.html">tNode</a> function called "AlertNodeMoving" </p><pre class="fragment">Inputs: time -- simulation time (for layer updating)
Data members updated: Mesh elements &amp; their geometry
Called by:  called outside of tMesh by routines that compute
            node movement (e.g., stream meandering, as implemented
            by tStreamMeander)
Calls: CheckTriEdgeIntersect, CheckLocallyDelaunay, UpdateMesh,
       LocateTriangle, tLNode::LayerInterpolation
Created: SL       
</pre> 
</div>
</div>
<a id="a725f9f50219ac7e4b4e80f7f61745d34" name="a725f9f50219ac7e4b4e80f7f61745d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725f9f50219ac7e4b4e80f7f61745d34">&#9670;&#160;</a></span>Print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::Print</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3307092e28fb1306c09001e524e3a7ee" name="a3307092e28fb1306c09001e524e3a7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3307092e28fb1306c09001e524e3a7ee">&#9670;&#160;</a></span>readRestart()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::readRestart </td>
          <td>(</td>
          <td class="paramtype">fstream &amp;&#160;</td>
          <td class="paramname"><em>rStr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#a3307092e28fb1306c09001e524e3a7ee">tMesh::readRestart()</a> Function </p>

</div>
</div>
<a id="aa156c800db8793912a3020e752f76f13" name="aa156c800db8793912a3020e752f76f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa156c800db8793912a3020e752f76f13">&#9670;&#160;</a></span>RepairMesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::RepairMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classt_ptr_list.html">tPtrList</a>&lt; tSubNode &gt; &amp;&#160;</td>
          <td class="paramname"><em>nbrList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#aa156c800db8793912a3020e752f76f13">tMesh::RepairMesh</a></p>
<p>This function repairs the "hole" in the mesh that is created when a node is deleted. Essentially, this function stiches the hole back together by adding edges and triangles as needed, preserving Delaunay-ness. The nodes around the hole are stored in the input parameter nbrList. As each new triangle is added, its "interior" point is removed from the neighbor list. The process of stitching proceeds iteratively until the hole itself is a Delaunay triangle.</p>
<p>For each set of 3 successive counter-clockwise points along the rim of the whole, the function calls Next3Delaunay to compare the potential triangle p0, p1, p2 with other potential triangles p0, p1, ptest (where ptest is each of the other nodes along the rim). When a Delaunay triangle is found, AddEdgeAndMakeTriangle is called to create the necessary edge and triangle objects, and the interior node is removed from the neighbor list. (or at least that's what gt is able to deduce...)</p>
<p>Inputs: nbrList &ndash; list of nodes surrounding the "hole" Returns: 1 if successful, 0 if not Calls: Next3Delaunay, AddEdgeAndMakeTriangle, MakeTriangle </p>

</div>
</div>
<a id="ab9681b88ea3beec71b25c3fadbc9e664" name="ab9681b88ea3beec71b25c3fadbc9e664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9681b88ea3beec71b25c3fadbc9e664">&#9670;&#160;</a></span>setNodeFromID()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::setNodeFromID </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tSubNode *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a58bb60c14c400f821efa812b0ad341a4" name="a58bb60c14c400f821efa812b0ad341a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58bb60c14c400f821efa812b0ad341a4">&#9670;&#160;</a></span>setVoronoiVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::setVoronoiVertices</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#a58bb60c14c400f821efa812b0ad341a4">tMesh::setVoronoiVertices</a></p>
<p>Each Delaunay triangle is associated with an intersection between three Voronoi cells, called a Voronoi vertex. These Voronoi vertices are used in computing the area of each Voronoi cell. The Voronoi vertex associated with each triangle is the circumcenter of the triangle. This routine finds the Voronoi vertex associated with each triangle by finding the triangle's circumcenter.</p>
<p>Assumes: correct triangulation with valid edge pointers in each tri. Data members modified: none Other objects modified: Voronoi vertices set for each <a class="el" href="classt_edge.html">tEdge</a> Modifications:</p><ul>
<li>reverted to earlier triangle-based computation, from an edge-based computation that takes 3x as long because NE = 3NT. In so doing, the definition of the Voronoi vertex stored in a <a class="el" href="classt_edge.html">tEdge</a> is changed to "left-hand", meaning the V. vertex associated with the edge's lefthand triangle (the vertex itself may or may not lie to the left of the edge). 1/98 GT</li>
<li>also moved circumcenter computation into a <a class="el" href="classt_triangle.html">tTriangle</a> mbr fn.</li>
<li>copied function to <a class="el" href="classt_mesh.html">tMesh</a> member from tStreamNet member, gt 3/98. Other fns now use "right-hand" definition; this fn may have to be changed. </li>
</ul>

</div>
</div>
<a id="ab77692808013d1f6124fabe7c261a48e" name="ab77692808013d1f6124fabe7c261a48e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77692808013d1f6124fabe7c261a48e">&#9670;&#160;</a></span>TellAboutNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::TellAboutNode </td>
          <td>(</td>
          <td class="paramtype">tSubNode *&#160;</td>
          <td class="paramname"><em>cn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6dc1693e4eb4d647985b1982c531e06f" name="a6dc1693e4eb4d647985b1982c531e06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc1693e4eb4d647985b1982c531e06f">&#9670;&#160;</a></span>TriWithEdgePtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classt_triangle.html">tTriangle</a> * <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::TriWithEdgePtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classt_edge.html">tEdge</a> *&#160;</td>
          <td class="paramname"><em>edgPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#a6dc1693e4eb4d647985b1982c531e06f">tMesh::TriWithEdgePtr</a></p>
<p>Finds and returns the triangle that points to edgPtr as one of its clockwise-oriented edges. </p>

</div>
</div>
<a id="a79f4924148c66d771a3bd47ef87fef32" name="a79f4924148c66d771a3bd47ef87fef32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f4924148c66d771a3bd47ef87fef32">&#9670;&#160;</a></span>UpdateMesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::UpdateMesh</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#a79f4924148c66d771a3bd47ef87fef32">tMesh::UpdateMesh</a></p>
<p>Updates mesh geometry:</p><ul>
<li>computes edge lengths</li>
<li>finds Voronoi vertices</li>
<li>computes Voronoi edge lengths</li>
<li>computes Voronoi areas for interior (active) nodes</li>
<li>updates CCW-edge connectivity</li>
</ul>
<p>Note that the call to CheckMeshConsistency is for debugging purposes and should be removed prior to release.</p>
<p>Calls: <a class="el" href="classt_mesh.html#aeac7892985d902ac09e63147d8d59147">MakeCCWEdges()</a>, <a class="el" href="classt_mesh.html#a58bb60c14c400f821efa812b0ad341a4">setVoronoiVertices()</a>, <a class="el" href="classt_mesh.html#a355454e97230dfb15b441c7453032cb1">CalcVoronoiEdgeLengths()</a>, <a class="el" href="classt_mesh.html#a0c03a0d5246105efdb77cc6853c57faf">CalcVAreas()</a>, <a class="el" href="classt_mesh.html#aff5058ee5d62594eac66b1ed67cdc538">CheckMeshConsistency()</a> Assumes: nodes have been properly triangulated Created: SL fall, '97 </p>

</div>
</div>
<a id="a94e9774031924a84293c81b20d4233aa" name="a94e9774031924a84293c81b20d4233aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e9774031924a84293c81b20d4233aa">&#9670;&#160;</a></span>writeRestart()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::writeRestart </td>
          <td>(</td>
          <td class="paramtype">fstream &amp;&#160;</td>
          <td class="paramname"><em>rStr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classt_mesh.html#a94e9774031924a84293c81b20d4233aa">tMesh::writeRestart()</a> Function</p>
<p>Called from tSimulator during simulation loop </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7508e9f09571ca93db5e4fd1bd68411f" name="a7508e9f09571ca93db5e4fd1bd68411f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7508e9f09571ca93db5e4fd1bd68411f">&#9670;&#160;</a></span>edgeList</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classt_mesh_list.html">tMeshList</a>&lt; <a class="el" href="classt_edge.html">tEdge</a> &gt; <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::edgeList</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab920491f63bc1a50cd4c29a937195429" name="ab920491f63bc1a50cd4c29a937195429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab920491f63bc1a50cd4c29a937195429">&#9670;&#160;</a></span>miNextEdgID</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::miNextEdgID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab27ff2bc94d0a6970e5b082f2e3ce2c6" name="ab27ff2bc94d0a6970e5b082f2e3ce2c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab27ff2bc94d0a6970e5b082f2e3ce2c6">&#9670;&#160;</a></span>miNextNodeID</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::miNextNodeID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7bbda0dc1dc090e066e20e9f0d3fee63" name="a7bbda0dc1dc090e066e20e9f0d3fee63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bbda0dc1dc090e066e20e9f0d3fee63">&#9670;&#160;</a></span>miNextTriID</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::miNextTriID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6e9e63101d16978322d5d2732edaeb8" name="ab6e9e63101d16978322d5d2732edaeb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e9e63101d16978322d5d2732edaeb8">&#9670;&#160;</a></span>mSearchOriginTriPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classt_triangle.html">tTriangle</a>* <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::mSearchOriginTriPtr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a485f86a92919290f8a69075f11915a84" name="a485f86a92919290f8a69075f11915a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485f86a92919290f8a69075f11915a84">&#9670;&#160;</a></span>nedges</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::nedges</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab176a2011b791982e7f6d9a0b08f1160" name="ab176a2011b791982e7f6d9a0b08f1160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab176a2011b791982e7f6d9a0b08f1160">&#9670;&#160;</a></span>nnodes</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::nnodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e13816739595f9f16db3953a328494d" name="a7e13816739595f9f16db3953a328494d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e13816739595f9f16db3953a328494d">&#9670;&#160;</a></span>nodeList</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classt_mesh_list.html">tMeshList</a>&lt; tSubNode &gt; <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::nodeList</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d0d563b4b8371c039f57d65863a4bad" name="a0d0d563b4b8371c039f57d65863a4bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0d563b4b8371c039f57d65863a4bad">&#9670;&#160;</a></span>NodeTable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tSubNode** <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::NodeTable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a63653c1fecfc91c8443f3f61f3be5cb7" name="a63653c1fecfc91c8443f3f61f3be5cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63653c1fecfc91c8443f3f61f3be5cb7">&#9670;&#160;</a></span>ntri</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::ntri</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5be9ed8ac9116e8c46c66c405723f46f" name="a5be9ed8ac9116e8c46c66c405723f46f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be9ed8ac9116e8c46c66c405723f46f">&#9670;&#160;</a></span>seed</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::seed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a071289cd4f1aa4c9acc4beb384b55552" name="a071289cd4f1aa4c9acc4beb384b55552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a071289cd4f1aa4c9acc4beb384b55552">&#9670;&#160;</a></span>simCtrl</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_simulation_control.html">SimulationControl</a>* <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::simCtrl</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0bb12cff37beb9d3aad9cb462e8665a2" name="a0bb12cff37beb9d3aad9cb462e8665a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb12cff37beb9d3aad9cb462e8665a2">&#9670;&#160;</a></span>triList</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classt_list.html">tList</a>&lt; <a class="el" href="classt_triangle.html">tTriangle</a> &gt; <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::triList</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8da103b2cf4437432a95b996b802db6c" name="a8da103b2cf4437432a95b996b802db6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da103b2cf4437432a95b996b802db6c">&#9670;&#160;</a></span>unsortList</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tSubNode &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classt_mesh_list.html">tMeshList</a>&lt; tSubNode &gt; <a class="el" href="classt_mesh.html">tMesh</a>&lt; tSubNode &gt;::unsortList</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/wr/Documents/tRIBSdev/merged_tRIBS/src/Headers/<a class="el" href="_classes_8h_source.html">Classes.h</a></li>
<li>/Users/wr/Documents/tRIBSdev/merged_tRIBS/src/tMesh/<a class="el" href="t_mesh_8h_source.html">tMesh.h</a></li>
<li>/Users/wr/Documents/tRIBSdev/merged_tRIBS/src/tMesh/<a class="el" href="t_mesh_8cpp.html">tMesh.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
